################################################################################
#  Licensed to the Apache Software Foundation (ASF) under one
#  or more contributor license agreements.  See the NOTICE file
#  distributed with this work for additional information
#  regarding copyright ownership.  The ASF licenses this file
#  to you under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance
#  with the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
# limitations under the License.
#################################################################################
from abc import ABC
from typing import Any
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, model_validator, ValidationError
from pydantic_core import PydanticSerializationError
from pyflink.common import Row


def row_serializer(row: Row) -> dict:
    """Serialize a PyFlink Row object to a dictionary for JSON serialization."""
    return {"type": "Row", "values": row._values}


class Event(BaseModel, ABC, extra="allow"):
    """Base class for all event types in the system. Event allow extra properties, but
    these properties are required isinstance of BaseModel, or json serializable.

    Attributes:
    ----------
    id : UUID
        Unique identifier for the event, automatically generated using uuid4.
    """

    id: UUID = Field(default_factory=uuid4)

    @model_validator(mode="after")
    def validate_extra(self) -> "Event":
        """Ensure init fields is serializable."""
        try:
            self.model_dump_json()
        except Exception as e:
            # If normal JSON serialization fails, check if it's only due to Row objects
            if self._contains_only_row_serialization_issues():
                # If it's only Row objects, that's acceptable
                return self
            # Otherwise, convert to ValidationError for model validation
            raise ValidationError.from_exception_data(
                "Event",
                [
                    {
                        "type": "value_error",
                        "loc": (),
                        "msg": "Fields must be JSON serializable",
                        "input": str(e),
                        "ctx": {"error": str(e)},
                    }
                ],
            )
        return self

    def _serialize_with_row_support(self) -> str:
        """Serialize the event with support for Row objects."""
        import json

        def custom_serializer(obj):
            if isinstance(obj, Row):
                return row_serializer(obj)
            elif isinstance(obj, UUID):
                return str(obj)
            elif hasattr(obj, "model_dump"):
                return obj.model_dump()
            raise TypeError(f"Object of type {type(obj)} is not JSON serializable")

        data = self.model_dump()
        return json.dumps(data, default=custom_serializer)

    def _contains_only_row_serialization_issues(self) -> bool:
        """Check if serialization issues are only due to Row objects."""
        import json

        # Check if all non-serializable objects are Row objects
        for key, value in self.model_dump().items():
            if not self._is_json_serializable(value):
                if not isinstance(value, Row):
                    return False
        return True

    def _is_json_serializable(self, obj) -> bool:
        """Check if an object is JSON serializable."""
        import json

        try:
            json.dumps(obj)
            return True
        except (TypeError, ValueError):
            return False

    def model_dump_json(self, **kwargs) -> str:
        """Override model_dump_json to handle Row objects."""
        try:
            return super().model_dump_json(**kwargs)
        except Exception:
            return self._serialize_with_row_support()

    def __setattr__(self, name: str, value: Any) -> None:
        super().__setattr__(name, value)
        # Ensure added property can be serialized.
        try:
            self.model_dump_json()
        except Exception as e:
            # If normal JSON serialization fails, check if it's only due to Row objects
            if not self._contains_only_row_serialization_issues():
                # If it's not only Row objects, re-raise the original exception
                if isinstance(e, PydanticSerializationError):
                    raise e
                else:
                    raise PydanticSerializationError(str(e))


class InputEvent(Event):
    """Event generated by the framework, carrying an input data that
    arrives at the agent.
    """

    input: Any


class OutputEvent(Event):
    """Event representing a result from agent. By generating an OutputEvent,
    actions can emit output data.

    Attributes:
    ----------
    output : Any
        The output result returned by the agent.
    """

    output: Any
